{"0": {
    "doc": "Home",
    "title": "Home",
    "content": "Hi, it’s Abdullah. I am software engineer from Turkey :tr:. I am interested in Rust programming, operating systems, virtualization and distributed systems. In general, I am interested in how things work internally, and how to make them even better. Doing optimization, dealing with complex systems and problems, working close to hardware and sharing my knowledge are the things that I like. I want to share my learning experience as well as some informative material in this blog. Please feel free to contact :). ",
    "url": "/",
    
    "relUrl": "/"
  },"1": {
    "doc": "OS Dev Journey",
    "title": "My Operating System Development Journey",
    "content": "I love to learn how things really work and build things from scratch. Since I am interested in virtualization, operating systems and work as an embedded software engineer, I wanted to give this a go. Here are some good resources: . | OS Dev website | Operating Systems: Three Easy Pieces . | There is also an online course on educative.io that follows this course. | . | Intel’s developer manual | Philipp Oppermann’s blog | . ",
    "url": "/blog/os-dev-journey#my-operating-system-development-journey",
    
    "relUrl": "/blog/os-dev-journey#my-operating-system-development-journey"
  },"2": {
    "doc": "OS Dev Journey",
    "title": "OS Dev Journey",
    "content": " ",
    "url": "/blog/os-dev-journey",
    
    "relUrl": "/blog/os-dev-journey"
  },"3": {
    "doc": "Building a Simple Kernel",
    "title": "Building a Simple Kernel for IA-32",
    "content": " ",
    "url": "/docs/os-dev-journey/simple-kernel.html#building-a-simple-kernel-for-ia-32",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#building-a-simple-kernel-for-ia-32"
  },"4": {
    "doc": "Building a Simple Kernel",
    "title": "How to get the most out of this post?",
    "content": "Before digging into some weird stuff, I want to share some thoughts to make sure that you are getting the most out of this blog post. First of all, this post encourages you to make lots of research and read a lot. There are several reasons for that: . | Getting used to reading official documentation is super beneficial and you will always find lots of hidden gems and hacks when you read official docs. | Although there are few great resources about OS development, this is a field where you should find and figure out things by yourself. | . Secondly, I will give you some hints and resources and ask you to stop and try it on your own. No matter how painful it is, please try those things yourself before going further. You may lose your mind but that’s the beauty of it :) . That’s enough already, let’s dig into the real thing. ",
    "url": "/docs/os-dev-journey/simple-kernel.html#how-to-get-the-most-out-of-this-post",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#how-to-get-the-most-out-of-this-post"
  },"5": {
    "doc": "Building a Simple Kernel",
    "title": "Introduction",
    "content": "Before digging into more complex stuff like CPU scheduling, paging, etc. we should of course have a bootable kernel. You can do some research about the boot process, we will just make a kernel that supports Multiboot. You can find the source code in here. ",
    "url": "/docs/os-dev-journey/simple-kernel.html#introduction",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#introduction"
  },"6": {
    "doc": "Building a Simple Kernel",
    "title": "Supporting multiboot specification",
    "content": "Multiboot specification is an open standard describing how a boot loader can load an x86 operating system kernel[*]. This way, any boot loader that support multiboot can load any multiboot compliant kernel and we won’t need to write our own boot loader. Of course one can say that there is Linux, so we don’t need to write our own operating system. But it is fun and helps you to understand how real systems really work. There are few requirements in the specification to make things work. First of all the specification says: . The Multiboot header must be contained completely within the first 8192 bytes of the OS image, and must be longword (32-bit) aligned. In general, it should come as early as possible and maybe embedded at the beginning of the text segment after the real executable header. So we will make our header 32-bit aligned and put it as early as possible. The header fields that we will be using are: . | Offset | Type | Field Name | . | 0 | u32 | magic | . | 4 | u32 | flags | . | 8 | u32 | checksum | . Let’s start implementing this. I prefer the Intel syntax. Let’s use it.intel_syntax noprefix . After this, we can start putting our 4-byte aligned header.align 4 # 1 .section .multiboot # 2 .long 0x1BADB002 # 3 .long 0 # 4 .long -(0x1BADB002 + 0) # 5 . | The multiboot header should be 32-bit (4 bytes) aligned. So we aligned the section by using .align directive. | We name this section as .multiboot and will be using this name, later on, to make sure that our header is 4-byte aligned and loaded very early in the executable file. | Magic number that indicates multiboot 1. | We don’t have any flags set. So we put 0. | We put the checksum value. It should give 0 when added to the other magic fields. | . To be able to assemble boot.s for our bare-bones x86 target, we need to use a cross-platform toolchain. We don’t want anything that depends on our host ecosystem. We can achieve this by using binutils. Let’s assemble boot.s and validate our multiboot header. i386-elf-as -msyntax=intel -mmnemonic=intel boot.s -o boot.o . As you can guess, -msyntax and -mmnemonic arguments are used for intel syntax. Validate the header: . grub-file --is-x86-multiboot boot.o || echo \":(\" . If the command does not give us a sad face, then we are good to go. ",
    "url": "/docs/os-dev-journey/simple-kernel.html#supporting-multiboot-specification",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#supporting-multiboot-specification"
  },"7": {
    "doc": "Building a Simple Kernel",
    "title": "Writing some code",
    "content": "The boot loader will jump to the _start symbol. If we don’t define the _start symbol, the linker will provide it with a predefined location. Our super simple kernel would probably work if we won’t define the _start symbol. Because we will put our kernel code to the beginning of the .text section. Otherwise this probably wouldn’t work.section .text #1 .global _start #2 _start: . | Executable part of the binary goes into .text section. | We make _start symbol accessible from outside of the file. | . Let’s print a very simple Hi message to see if everything works fine. Since we don’t have any underlying OS (basically we are the OS), we don’t have anything like printf or write system call. Because the system calls are provided by the operating system. We need to implement such things ourselves in this wild, bare-bones environment. We will use the VGA text mode to print to screen. The one we will be using in qemu provides a 80x25 16-bit buffer located at physical memory address 0xB8000. The layout of a character is like this: . | Bits | Description | . | 0-7 | Code point | . | 8-11 | Foreground color | . | 12-15 | Background color | . You can also check out the 4-bit color palette here. To print a white-on-black HI message, we need to do small math.section .text .global _start _start: mov word ptr [0xb8000], 'h' | (0xF &lt;&lt; 8) mov word ptr [0xb8000 + 0x2], 'i' | (0xF &lt;&lt; 8) hlt . We left-shift the foreground color (WHITE) by 8 bits and OR it with h and i to get white-on-black characters and put it to physical address 0xb8000 which is the address of the VGA buffer. ",
    "url": "/docs/os-dev-journey/simple-kernel.html#writing-some-code",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#writing-some-code"
  },"8": {
    "doc": "Building a Simple Kernel",
    "title": "Running the code",
    "content": "We will be using qemu to run our kernel. To generate a bootable kernel, we again need to use the cross-platform linker. But we cannot use the linker like that because we also need to tell the linker how to construct the executable file. Let’s think about our needs for a second: . | Our entry point’s name is _start | Multiboot header should be 4-byte aligned. | Multiboot header should be within the first 8192 bytes of the OS image. (We can just put it to the top) | Any OS data should not collide with any special locations. (Like VGA buffer in 0xb8000) | . DIY: Try to write your own linker script by considering the requirements above. If you didn’t write your own linker script, it is fine :) Here is a very minimalistic linker script (linker.ld): . ENTRY(_start) /* 1 */ SECTIONS { . = 1M; /* 2 */ /* 3 */ .multiboot : ALIGN(4) { *(.multiboot) } /* 4 */ .text : { *(.text) } } . | We defined _start as the entry point. | We make the kernel code start from 1 MB, it is a convenient location to put the kernel code. Also, this way our kernel code won’t collide with the VGA buffer. | We put the .multiboot section to top and align it to 4 bytes. | We put the actual code. | . Note: You can see the linker script that is used by the linker by using --verbose argument . We can finally run our kernel. Let’s create a simple build script. #!/bin/sh i386-elf-as -msyntax=intel -mmnemonic=intel boot.s -o boot.o # 1 i386-elf-ld -T linker.ld boot.o -o kernel.bin # 2 . | We assemble the boot.s. | We generated our kernel executable by running the linker with linker.ld. | . And let’s run the kernel./build.sh &amp;&amp; qemu-system-i386 -kernel kernel.bin . If everything works fine, you should see hi printed to qemu screen. ",
    "url": "/docs/os-dev-journey/simple-kernel.html#running-the-code",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#running-the-code"
  },"9": {
    "doc": "Building a Simple Kernel",
    "title": "Adding some C code",
    "content": "Assembly is great, but it would be really painful to extend our kernel’s capabilities with it. So let’s create a helper C file for VGA. The first thing we need to know is that we cannot use anything that depends on an underlying OS like stdio. DIY: Try to write your own vga helper. It should be easy to use and incrementally write the characters starting from the physical address 0xb8000. Since this is just an abstraction and nothing really fancy happens, I will just provide the files. vga.h . #ifndef VGA_H_ #define VGA_H_ typedef enum { VGA_BLACK, VGA_BLUE, VGA_GREEN, VGA_CYAN, VGA_RED, VGA_MAGENTA, VGA_BROWN, VGA_WHITE, VGA_GRAY, VGA_LIGHT_BLUE, VGA_LIGHT_GREEN, VGA_LIGHT_CYAN, VGA_LIGHT_RED, VGA_LIGHT_MAGENTA, VGA_YELLOW, VGA_BRIGHT_WHITE } vga_color_t; void vga_print(const char *); void vga_set_color(vga_color_t bg, vga_color_t fg); #endif . vga.c . #include \"vga.h\" #include &lt;stddef.h&gt; #include &lt;stdint.h&gt; #define MAX_COL 80 #define MAX_ROW 25 #define VGA_ADDR 0xb8000 #define BG_COL(X) (X &lt;&lt; 12) #define FG_COL(X) (X &lt;&lt; 8) static uint16_t *const VGA_BUFFER = (uint16_t *)VGA_ADDR; static int vga_index = 0; static uint16_t active_color = BG_COL(VGA_BLACK) | FG_COL(VGA_BRIGHT_WHITE); static void vga_print_char(char character) { if (vga_index &gt;= MAX_COL * MAX_ROW) { return; } if ('\\n' == character) { vga_index = vga_index + MAX_COL - ((vga_index) % MAX_COL); return; } VGA_BUFFER[vga_index++] = active_color | character; } void vga_print(const char *string) { for (int i = 0;; ++i) { if (string[i] == '\\0') { return; } vga_print_char(string[i]); } } void vga_set_color(vga_color_t bg, vga_color_t fg) { active_color = BG_COL(bg) | FG_COL(fg); } . Our compiled code should not depend on the host environment. So we will use -ffreestanding argument of gcc. The manual file says: . -ffreestanding Assert that compilation takes place in a freestanding environment. This implies -fno-builtin. A freestanding environment is one in which the standard library may not exist, and program startup may not necessarily be at “main”. The most obvious example is an OS kernel. This is equivalent to -fno-hosted. And we just want to compile the file, not link it. So we will use -c argument for that. build.sh . #!/bin/sh i386-elf-as -msyntax=intel -mmnemonic=intel boot.s -o boot.o i386-elf-gcc -c vga.c -ffreestanding -o vga.o i386-elf-ld -T linker.ld boot.o vga.o -o kernel.bin . Note that the object file vga.o is added to call to the linker. Otherwise, we won’t be able to call any function of vga from boot. ",
    "url": "/docs/os-dev-journey/simple-kernel.html#adding-some-c-code",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#adding-some-c-code"
  },"10": {
    "doc": "Building a Simple Kernel",
    "title": "Calling a C function",
    "content": "To properly call a function, we need to use call instruction. What this instruction does is: . | Push eip to the stack (so that we can return from the function) | Jump to the function’s address | . Simple, right? . Not so fast. Don’t forget that we are the OS, so we don’t have a stack. To have a stack, we first need to reserve some bytes and set the stack pointer (esp). Our stack will be some uninitialized bytes. The .bss section contains statically allocated variables that are declared but have not been assigned a value yet[*]. So let’s put our stack to .bss section. boot.s .section .text .global _start _start: lea esp, [stack_top] mov word ptr [0xb8000], 'h' | (0xF &lt;&lt; 8) mov word ptr [0xb8000 + 0x2], 'i' | (0xF &lt;&lt; 8) hlt .section .bss stack_bottom: .skip 8192 # 8 KB stack_top: . We put our stack to the .bss section. Note that stack_top is below stack_bottom. Because stacks grow through the lower addresses. Let’s add the .bss section to our linker script as well. ENTRY(_start) SECTIONS { . = 1M; .multiboot : ALIGN(4) { *(.multiboot) } .text : { *(.text) } .bss : { *(.bss) } } . But we are still not done :) . ",
    "url": "/docs/os-dev-journey/simple-kernel.html#calling-a-c-function",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#calling-a-c-function"
  },"11": {
    "doc": "Building a Simple Kernel",
    "title": "Segmentation",
    "content": "We can consider an operating system as an abstraction over hardware. To make our lives easier, provide security, and improve performance, operating systems virtualize the physical memory. Memory addresses that we use are logical addresses that are translated into physical addresses with the help of the hardware. The hardware also provides us some security features. DIY: To understand the segmentation, I really suggest you to go read Segmentation part of the OSTEP book. I will just show you the basic segmentation setup in IA-32 architecture by skimming through the Intel’s developer manual Volume 3, Chapter 3. All of the references are from Intel’s developer manual, Volume 3, Chapter 3. Also, we won’t do paging on this post. This is too much already. It says in 3.1 . A logical address consists of a segment selector and an offset. The segment selector is a unique identifier for a segment. Among other things, it provides an offset into a descriptor table (such as the global descriptor table, GDT) to a data structure called a segment descriptor. Each segment has a segment descriptor, which specifies the size of the segment, the access rights and privilege level for the segment, the segment type, and the location of the first byte of the segment in the linear address space (called the base address of the segment). The offset part of the logical address is added to the base address for the segment to locate a byte within the segment. The base address plus the offset thus forms a linear address in the processor’s linear address space. And in 3.2.1 . To implement a basic flat memory model with the IA-32 architecture, at least two segment descriptors must be created, one for referencing a code segment and one for referencing a data segment (see Figure 3-2). Both of these segments, however, are mapped to the entire linear address space: that is, both segment descriptors have the same base address value of 0 and the same segment limit of 4 GBytes. By setting the segment limit to 4 GBytes, the segmentation mechanism is kept from generating exceptions for out of limit memory references, even if no physical memory resides at a particular address. To achieve a basic flat model, what we have to do is: . | Create a GDT that contains 3 segment descriptors: . | Null segment descriptor. | Code segment descriptor. | Data segment descriptor. | . | Create a GDT descriptor: . | Size of the GDT - 1. | Address of the GDT. | . | Load the correct values to segment registers: . | Code segment register should point to the code segment descriptor. | Other segment registers should point to the data segment descriptor. | . | . You can see the visual representation of GDT here. So let’s start by creating the null descriptor. This is required by the IA-32 architecture. boot.s ... hlt gdt: .long 0x0 .long 0x0 . After that let’s create the code and data segment descriptors. But to do that, let’s first check out the structure of the segment descriptor. You can check out the detailed explanation of the segment descriptor structure in here. Please check it out. Otherwise, you won’t understand the following part. DIY: I put the first null descriptor for you. By following the document from OSDev, try to set up the code and data segment descriptors. boot.s . gdt: .long 0x0 .long 0x0 code_desc: .word 0xffff .word 0x0 .byte 0x0 .byte 0x9a .byte 0xcf .byte 0x0 data_desc: .word 0xffff .word 0 .byte 0 .byte 0x92 .byte 0xcf .byte 0 . After this, we need one more descriptor that describes the GDT. It is like a pointer to an array that contains pointers. DIY: Create a GDT descriptor called gdt_desc and put 16-bit size of GDT - 1 and 32-bit pointer to GDT. boot.s . data_desc: ... gdt_desc: .word (gdt_desc - gdt - 1) .long gdt . And finally, we can load our GDT to gdtr (Global Descriptor Table Register) and fill the segment registers. boot.s .section .text .global _start _start: lea esp, [stack_top] lgdt [gdt_desc] # 1 mov ax, 0x10 mov ss, ax # 2 mov ds, ax mov es, ax mov fs, ax jmp 0x8:.load_cs # 3 .load_cs: . | We load our GDT descriptor to gdtr by using lgdt (Load Global Descriptor Table) instruction. | We make the segment registers (other than CS) point to the data segment descriptor. | Since we cannot write to CS register, we did a long jump to load 0x8 to the CS register. | . But wait a minute, what are these 0x10 and 0x8? How are these make the segment registers to point to the correct descriptor? . Yeah, good point! . As it says in 3.4.2: . A segment selector is a 16-bit identifier for a segment (see Figure 3-6). It does not point directly to the segment but instead points to the segment descriptor that defines the segment. | First 2 bits of the segment selector is Requested Privilege Level, since we are just using the privilege level 0, we will make this 0 as well. | The following bit is the Table Indicator. It indicates if the table is LDT or GDT. It is GDT, so we will make this 0. | Remaining bits indicate the index of the segment descriptor. | . We load 0x8 to CS. The underlying math is this: . | RPL is 0 | Table Indicator is 0 | Index is 1 | . (1 &lt;&lt; 3) = 0x8 . And we load 0x10 to other segment registers. | RPL is 0 | Table Indicator is 0 | Index is 2 | . (2 &lt;&lt; 3) = 0x10 . ",
    "url": "/docs/os-dev-journey/simple-kernel.html#segmentation",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#segmentation"
  },"12": {
    "doc": "Building a Simple Kernel",
    "title": "Calling the C function (for real)",
    "content": "Finally, we can call the helper function that we wrote. To properly call a function, we need to follow some calling conventions. DIY: Call the function by following the cdecl convention . The arguments are pushed to stack from right-to-left, and the caller cleans up the pushed arguments after the function returns. Let’s print something fancy.load_cs: push 0xF # int fg push 0x4 # int bg call vga_set_color add esp, 0x8 # clean up the stack lea eax, [my_brain_text] # Load the string's address push eax # const char * call vga_print add esp, 0x4 push 0x4 push 0xF call vga_set_color add esp, 0x8 lea eax, [hurts_text] push eax call vga_print add esp, 0x4 hlt my_brain_text: .ascii \"My Brain\\n\\0\" hurts_text: .ascii \"Hurts\\n\\0\" . ",
    "url": "/docs/os-dev-journey/simple-kernel.html#calling-the-c-function-for-real",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#calling-the-c-function-for-real"
  },"13": {
    "doc": "Building a Simple Kernel",
    "title": "What’s next?",
    "content": "We will deal with the interrupts and paging on the next posts. Feel free to contact if you find anything wrong, you have any questions or any ideas. ",
    "url": "/docs/os-dev-journey/simple-kernel.html#whats-next",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html#whats-next"
  },"14": {
    "doc": "Building a Simple Kernel",
    "title": "Building a Simple Kernel",
    "content": "May 10, 2021 . ",
    "url": "/docs/os-dev-journey/simple-kernel.html",
    
    "relUrl": "/docs/os-dev-journey/simple-kernel.html"
  },"15": {
    "doc": "Small Projects",
    "title": "Small (but fun) Projects",
    "content": "You might find any kind of projects in here. Although I like to explain things in detail, I will kindly ask you to have some base knowledge and create simple projects based on that knowledge. ",
    "url": "/blog/small-projects#small-but-fun-projects",
    
    "relUrl": "/blog/small-projects#small-but-fun-projects"
  },"16": {
    "doc": "Small Projects",
    "title": "Small Projects",
    "content": " ",
    "url": "/blog/small-projects",
    
    "relUrl": "/blog/small-projects"
  },"17": {
    "doc": "x86_64 Tcp Server",
    "title": "x86_64 Tcp Server",
    "content": " ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#x86_64-tcp-server",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#x86_64-tcp-server"
  },"18": {
    "doc": "x86_64 Tcp Server",
    "title": "Introduction",
    "content": "I like reversing things, and being a reverse engineer means being a computer geek who knows lots of things’ internals. And knowledge of assembly is one of them. So we will make a simple assembly project. Since there are many resources about assembly, I don’t want to explain basic things like what does the mov instruction do. Instead, I will suggest you some resources and kindly ask you to study them first. After reading this blog post, - assuming I am not terrible at explaining stuff :) - you will have a basic understanding of: . | Properly using and understanding the stack, | Calling conventions, | Using rep instructions, | Writing code for different platforms by using NASM preprocessor, | Doing syscalls. | . By saying assembly, I am referring to x64 assembly. You can find the source code in here. ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#introduction",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#introduction"
  },"19": {
    "doc": "x86_64 Tcp Server",
    "title": "Requirements",
    "content": ". | To understand things covered in this post, you should have at least a basic understanding of assembly. | You should know what are sockets. If you did socket programming before, you would probably understand every syscall easily. | . ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#requirements",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#requirements"
  },"20": {
    "doc": "x86_64 Tcp Server",
    "title": "Resources",
    "content": ". | Amazing resource about x86 and x64 assembly and much more. | Intel’s developer manual. | . ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#resources",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#resources"
  },"21": {
    "doc": "x86_64 Tcp Server",
    "title": "Syscalls",
    "content": "System Calls are used to call a kernel service from the userland. The goal is to be able to switch from user mode to kernel mode, with the associated privileges. For example, when we call printf in C, or print in Python, it calls the write system call to print something to the standard output. Or when we want to open some file in C, we call open system call. So we will start by doing a super simple ‘Hello World’ application by calling the write system call. The prototype of the write function is like this: . ssize_t write(int fd, const void *buf, size_t count); . Making a syscall in C is super simple, you pass the correct arguments and call the correct function. But calling a function properly in assembly is a little bit different. We cannot call a syscall like this: . syscall write(1, buffer, 10) . Firstly, system calls are not like regular functions. We trigger an interrupt to make the OS take care of the system call. And secondly, write(1, buffer, 10) like C won’t work in assembly because there is no mechanism to pass the parameters magically in assembly. So we need to know how the kernel expects the parameters. The calling convention of x86_64 System V ABI is like this (these are the ones that we will use, for more detail please go to the reference): . | Parameters are put in registers rdi, rsi, rdx from left to right. | The stack pointer (rsp) needs to be 16-byte aligned at call. | The return value should be put to rax. | rbx, rsp, rbp should be preserved. This means that they must be the same before and after the function call. | . As I said earlier, system calls are not like regular function calls. We are requesting a service from the operating system. To make a system call, we need to provide to kernel the syscall that we want to make. Like write or open. And then we can make the system call. We can specify the system call by putting the number of the system call to rax before making the system call. You can find 64-bit system call numbers of Linux in here. As you can see, the number of write system call is 1. Here is an example usage of write system call: . ; export the main symbol so that `gcc` can find it global main section .text main: ; write(stdout, HELLO_STR, 14) mov rax, 1 ; Syscall number of `write` mov rdi, 1 ; Stdout mov rsi, HELLO_STR mov rdx, 14 ; Length of HELLO_STR syscall ; exit(0) mov rax, 60 ; Syscall number of `exit` mov rdi, 0 syscall section .data HELLO_STR: db \"Hello, World!\", 10, 0 ; \"Hello, World!\" followed by a newline and the null character. Let’s run it: . nasm -f elf64 hello_world.s &amp;&amp; gcc hello_world.o -o hello_world ./hello_world $ Hello, World! . DIY: Take input from stdin by using read syscall and print the string that you read. Hint: You use resb to allocate a buffer or make enough space on the stack and use the stack. ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#syscalls",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#syscalls"
  },"22": {
    "doc": "x86_64 Tcp Server",
    "title": "Using the NASM Preprocessor",
    "content": "As you can see, we put 1 for write and 60 for exit to rax. Is it really necessary to memorize these numbers or look at the table each time? Of course not, like in C, we will use the NASM’s preprocessor to define those numbers. Let’s create a file named defines.s. %define EXIT 60 %define READ 0 %define WRITE 1 %define CLOSE 3 %define ACCEPT 43 %define SOCKET 41 %define BIND 49 %define SETSOCKOPT 54 %define LISTEN 50 %define STDOUT 1 . Now we can include this file and change the syscall with the corresponding names. %include \"defines.s\" ... mov rax, WRITE ... mov rax, EXIT ... Another reason that we use the preprocessor is to make it super easy to write code for both OS X and Linux. There are some small differences between the OS X and Linux (of course there are huge differences but I am talking about our little program): . | System call numbers, | Some data structures, | Name of the ‘main’ function, | OS X requires a base number that needs to be added to each system call. | . Let’s enhance our definitions by using the conditionals: . ; Like in C, if we compile our code by defining PLATFORM_OSX, first part will be active, otherwise the `elif` part will be active. %ifdef PLATFORM_OSX %define SYSCALL_BASE 0x2000000 %define EXIT 1 %define READ 3 %define WRITE 4 %define CLOSE 6 %define ACCEPT 30 %define SOCKET 97 %define BIND 104 %define SETSOCKOPT 105 %define LISTEN 106 %elifdef PLATFORM_LINUX %define SYSCALL_BASE 0 %define EXIT 60 %define READ 0 %define WRITE 1 %define CLOSE 3 %define ACCEPT 43 %define SOCKET 41 %define BIND 49 %define SETSOCKOPT 54 %define LISTEN 50 %endif %define STDOUT 1 ; We don't want to add the base number every time we make a syscall, ; this is a nice way to prevent that. %define SYSCALL(NUM) (SYSCALL_BASE + NUM) . And also, on OS X, the compiler expects _main symbol to be exported. So we need to make it conditional as well. DIY: Update hello_world.s to run for both OS X and Linux . Here is the final version of hello_world.s: . %include \"defines.s\" %ifdef PLATFORM_LINUX global main %elifdef PLATFORM_OSX global _main %endif section .text %ifdef PLATFORM_LINUX main: %elifdef PLATFORM_OSX _main: %endif ; write(stdout, HELLO_STR, 14) mov rax, SYSCALL(WRITE) mov rdi, STDOUT mov rsi, HELLO_STR mov rdx, 14 syscall ; exit(0) mov rax, SYSCALL(EXIT) mov rdi, 0 syscall section .data HELLO_STR: db \"Hello, World!\", 10, 0 ; \"Hello, World!\" followed by a newline and the null character. Now, we need to specify the platform on the compilation, and there is a small tweak that we need to do for OS X. So let’s create a shell script to ease the build. In build.sh: . #!/bin/bash FILES=(hello_world) if [ \"PLATFORM_OSX\" = \"$1\" ] then FORMAT=\"macho64\" PLATFORM=\"$1\" else FORMAT=\"elf64\" PLATFORM=\"PLATFORM_LINUX\" fi OBJ_FILES=\"\" for f in ${FILES[@]} do echo 'Building: ' $f nasm -d$PLATFORM -f $FORMAT $f.s OBJ_FILES+=\"$f.o \" done echo \"Linking $OBJ_FILES\" if [ \"PLATFORM_OSX\" = \"$PLATFORM\" ] then gcc -Wl,-no_pie $OBJ_FILES -o hello_world else gcc $OBJ_FILES -o hello_world fi . The script gets a platform specifier and compiles each file in FILES list for the target platform. Let’s run it: . chmod +x build.sh # For Linux ./build.sh PLATFORM_LINUX # For OS X ./build.sh PLATFORM_OSX ./hello_world . ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#using-the-nasm-preprocessor",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#using-the-nasm-preprocessor"
  },"23": {
    "doc": "x86_64 Tcp Server",
    "title": "Creating a Socket",
    "content": "To create a socket, we need to use socket system call. Here is the prototype of socket: . int socket(int domain, int type, int protocol); . | domain argument specifies a communication domain. Since we want to use IPv4 internet protocols, we want to use AF_INET - which expands to 2 - for this. AF_INET is defined in sys/socket.h. | . Hint: You can print the value of things by writing a C program or use an IDE or a text editor with an extension to jump to the definition of something. For example, I am using neovim with coc. | type will be SOCK_STREAM - which expands to 1 - for a TCP connection. | protocol will be 0 since we use a single protocol. | . In socket.s: . %include \"defines.s\" %define AF_INET 2 %define SOCK_STREAM 1 ; Export the `socket_listen` function global socket_listen section .text socket_listen: ; socket(rdi: AF_INET, rsi: SOCK_STREAM, rdx: 0) mov rax, SYSCALL(SOCKET) mov rdi, AF_INET mov rsi, SOCK_STREAM mov rdx, 0 syscall . Now we can find the created socket descriptor on rax register. ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#creating-a-socket",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#creating-a-socket"
  },"24": {
    "doc": "x86_64 Tcp Server",
    "title": "Binding a Socket",
    "content": "To assign an address and a port to a socket, we need to make a bind syscall. Here is the prototype of bind: . | sockfd is the socket’s file descriptor which is returned from the socket syscall. | addr is a pointer to the address information. | addrlen is the length of address information. | . Until this point, we only deal with values and not pointers. But this time the addr parameter points to a location that stores the actual data. So we need to reserve some space for the data. If we would use C, we would probably define addr as a local variable like this: . struct sockaddr_in addr; // ... bind(.., &amp;addr, sizeof(addr)); . As you might know, non-static local variables are reserved on the stack. But before reserving a space for addr on the stack, we actually need to reserve a space on the stack for our function which is generally called as the stack frame. ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#binding-a-socket",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#binding-a-socket"
  },"25": {
    "doc": "x86_64 Tcp Server",
    "title": "Properly Setting Up the Stack Frame",
    "content": "Each function generally has its own stack frame. I am saying generally because some optimization might omit allocating the stack process. This stack frame is used to store our local variables and return addresses. Let’s say the main function calls foo function. Right after the call happens, the stack would look like this: . +------------------------+ | Lower Addresses | +------------------------+ rsp -&gt; | return address of main | some local variable | rbp -&gt; | +------------------------+ | Higher Addresses | +------------------------+ . The call instruction pushes the return address of main to the stack. Because think about it, how would the CPU know, which instruction to return to otherwise? The part of the stack that is between rsp and rbp is called a stack frame. Right after the call, the stack frame is the main function’s stack frame. To reserve a stack frame for foo, we do this: . | Save rbp. Because we need to restore it before we return from foo. Otherwise, we would lose main function’s base of the stack. | Move rbp to rsp. This would move the base of the stack frame of foo on top of the stack frame of main. | Reserve the necessary space by decrementing rsp. | . After doing the above steps, our stack will look like this: . +------------------------+ | Lower Addresses | +------------------------+ rsp -&gt; | reserved | reserved | rbp -&gt; | saved rbp | return address of main | some local variable | +------------------------+ | Higher Addresses | +------------------------+ . And to return from the function, we will restore the caller’s stack frame not to mess things up. | Move rsp to rbp. This will make us discard all the reserved space. | Pop rbp. By doing this, we will restore the saved rbp and, since pop increments rsp we will also restore the rsp. | Execute ret. This will pop the return address to rip so that the program will continue to execute the caller function. | . ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#properly-setting-up-the-stack-frame",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#properly-setting-up-the-stack-frame"
  },"26": {
    "doc": "x86_64 Tcp Server",
    "title": "Reserving addr On Stack",
    "content": "Let’s properly set up the stack and reserve enough space for addr. struct sockaddr is a generic data structure and for IP-based communication, we need to use struct sockaddr_in. If we use C, we would use struct sockaddr_in and case it to struct sockaddr * when we call the bind function. On Linux, the definition of struct sockaddr_in is like this: . struct sockaddr_in { short sin_family; unsigned short sin_port; struct in_addr sin_addr; char sin_zero[8]; } . If you go to the definition by yourself, you will see some fancy stuff. This is a simplified version. | sin_family will be AF_INET like we did before. | sin_port will be the port number in network byte-order. | in_addr is an unsigned long and it will be INADDR_ANY. | sin_zero will be bunch of zeros. | . In C, you can assign a variable with the equal sign and do not care about the size. But in assembly, we need to put the variables in the correct place, in the correct order, in the correct size. Since the size of the struct sockaddr is 16 bytes, let’s start improving our function by reserving 16 bytes. socket_listen: ; Set up the stack frame push rbp mov rbp, rsp ; Reserve 16 bytes on stack sub rsp, 0x10 . After that, let’s correctly fill the reserved space for the address. socket_listen: ... mov word [rsp+0x0], AF_INET mov word [rsp+0x2], 23569 ; port 4444 in network byte-order. mov dword[rsp+0x4], INADDR_ANY mov qword[rsp+0x8], 0 ; zero out `sin_zero` . There is a thing that we need to do. On OS X, the definition of struct sockaddr_in is like this: . struct sockaddr_in { __uint8_t sin_len; __uint8_t sin_family; __uint16_t sin_port; struct in_addr sin_addr; char sin_zero[8]; } . As you can see, now the size of sin_family is 1 byte and a new field called sin_len which is the size of addr is added. So we need to use conditional assembly in here. %ifdef PLATFORM_LINUX mov word [rsp+0x0], AF_INET ; 2 bytes family %elifdef PLATFORM_OSX mov byte [rsp+0x0], 0x10 ; size of the `addr` mov byte [rsp+0x1], AF_INET ; 1 byte family %endif mov word [rsp+0x2], 23569 ; port 4444 in network byte-order. mov dword[rsp+0x4], INADDR_ANY mov qword[rsp+0x8], 0 ; zero out `sin_zero` . Now we can call bind. %include \"defines.s\" %define AF_INET 2 %define SOCK_STREAM 1 %define INADDR_ANY 0 global socket_listen section .text socket_listen: push rbp mov rbp, rsp sub rsp, 0x10 ; socket(rdi: AF_INET, rsi: SOCK_STREAM, rdx: 0) mov rax, SYSCALL(SOCKET) mov rdi, AF_INET mov rsi, SOCK_STREAM mov rdx, 0 syscall %ifdef PLATFORM_LINUX mov word [rsp+0x0], AF_INET ; 2 bytes family %elifdef PLATFORM_OSX mov byte [rsp+0x0], 0x10 ; size of the `addr` mov byte [rsp+0x1], AF_INET ; 1 byte family %endif mov word [rsp+0x2], 23569 ; port 4444 in network byte-order. mov dword[rsp+0x4], INADDR_ANY mov qword[rsp+0x8], 0 ; zero out `sin_zero` ; bind(rdi: socket, rsi: addr, rdx: sizeof(addr)) mov rdi, rax mov rax, SYSCALL(BIND) mov rsi, rsp mov rdx, 0x10 syscall . You might not see it at first but we have a problem in here. socket returns the created socket descriptor in rax and bind returns the status code in rax as well. So after we call bind, we lost the returned socket descriptor. So let’s save it to rbx before we call socket. We are saving it to rbx because we know that it will be preserved as it said in the calling convention. We are expecting rbx to remain unchanged but also the function that calls socket_listen expects rbx to remain unchanged. So we need to save it before we change it so that we can restore it later. %include \"defines.s\" %define AF_INET 2 %define SOCK_STREAM 1 %define INADDR_ANY 0 global socket_listen section .text socket_listen: push rbp mov rbp, rsp push rbx ; --&gt; NEW: save `rbx` sub rsp, 0x10 ; socket(rdi: AF_INET, rsi: SOCK_STREAM, rdx: 0) mov rax, SYSCALL(SOCKET) mov rdi, AF_INET mov rsi, SOCK_STREAM mov rdx, 0 syscall mov rbx, rax ; --&gt; NEW %ifdef PLATFORM_LINUX mov word [rsp+0x0], AF_INET ; 2 bytes family %elifdef PLATFORM_OSX mov byte [rsp+0x0], 0x10 ; size of the `addr` mov byte [rsp+0x1], AF_INET ; 1 byte family %endif mov word [rsp+0x2], 23569 ; port 4444 in network byte-order. mov dword[rsp+0x4], INADDR_ANY mov qword[rsp+0x8], 0 ; zero out `sin_zero` ; bind(rdi: socket, rsi: addr, rdx: sizeof(addr)) mov rax, SYSCALL(BIND) mov rdi, rbx ; --&gt; NEW mov rsi, rsp mov rdx, 0x10 syscall . ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#reserving-addr-on-stack",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#reserving-addr-on-stack"
  },"27": {
    "doc": "x86_64 Tcp Server",
    "title": "Listening on a Socket",
    "content": "Now we need to listen for connection on the socket. Prototype of listen is: . int listen(int sockfd, int backlog); . | sockfd is the socket descriptor that is returned from socket. | backlog argument defines the maximum length to which queue of pending connections for sockfd may grow. We assign this to 5 just in case. | . socket_listen: ... ; listen(rdi: socket, rsi: backlog(5)) mov rax, SYSCALL(LISTEN) mov rdi, rbx mov rsi, 5 syscall . And we can finally restore the stack and rbx and return. socket_listen: ... ; Set the return value to the socket descriptor mov rax, rbx ; Restore rbx mov rbx, QWORD [rsp + 0x10] ; Properly return from the function mov rsp, rbp pop rbp ret . ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#listening-on-a-socket",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#listening-on-a-socket"
  },"28": {
    "doc": "x86_64 Tcp Server",
    "title": "Catching Failures",
    "content": "As you might know, system calls might fail. So we need to detect them before making a new call. Here is how we can do that: . socket_listen: ; Save the stack's base pointer. push rbp mov rbp, rsp push rbx sub rsp, 0x10 ; socket(rdi: AF_INET, rsi: SOCK_STREAM, rdx: 0) mov rax, SYSCALL(SOCKET) mov rdi, AF_INET mov rsi, SOCK_STREAM mov rdx, 0 syscall ; Socket returns &lt;0 on failure. cmp rax, 0 jl .socket_failed ; Save the returned socket descriptor. mov rbx, rax %ifdef PLATFORM_LINUX mov word [rsp+0x0], AF_INET %elifdef PLATFORM_OSX mov byte [rsp+0x0], 0x10 mov byte [rsp+0x1], AF_INET %endif mov word [rsp+0x2], 23569 mov dword[rsp+0x4], INADDR_ANY mov qword[rsp+0x8], 0 ; bind(rdi: socket, rsi: addr, rdx: sizeof(addr)) mov rax, SYSCALL(BIND) mov rdi, rbx mov rsi, rsp mov rdx, 0x10 syscall cmp rax, 0 jl .bind_failed ; listen(rdi: socket, rsi: backlog(5)) mov rax, SYSCALL(LISTEN) mov rdi, rbx mov rsi, 5 syscall cmp rax, 0 jl .listen_failed ; Restore the socket to return. mov rax, rbx jmp .ret .socket_failed: mov rsi, SOCKET_FAILED jmp .err_msg .bind_failed: mov rsi, BIND_FAILED jmp .err_msg .listen_failed: mov rsi, LISTEN_FAILED jmp .err_msg .err_msg: ; write(rdi: fd, rsi: buffer, rdx: count of bytes to write); mov rax, SYSCALL(WRITE) mov rdi, 1 mov rdx, 20 ; Not generic :( syscall mov rax, -1 .ret: ; Restore rbx mov rbx, QWORD [rsp + 0x10] ; Properly return from the function mov rsp, rbp pop rbp ret section .data SOCKET_FAILED: db \"socket() failed\", 10, 0 BIND_FAILED: db \"bind() failed\", 10, 0 LISTEN_FAILED: db \"listen() failed\", 10, 0 ACCEPT_FAILED: db \"accept() failed\", 10, 0 . What we do is fairly simple, after each system call, we checked the returned value and see if an error is occurred. And instead of copy-pasting the write syscall, we jumped to .err_msg which prints the string that is passed with rsi. You can see that the length of the string is not generic. We will solve that really soon :) . ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#catching-failures",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#catching-failures"
  },"29": {
    "doc": "x86_64 Tcp Server",
    "title": "Running Our Server",
    "content": "Of course, our server won’t do anything right now, but we can at least trace the system calls and see if things work. DIY: Write the main function that calls socket_listen and edit build.sh to compile and run the server. Let’s create a simple main file main.s: . %include \"defines.s\" extern socket_listen %ifdef PLATFORM_OSX global _main %elifdef PLATFORM_LINUX global main %endif section .text %ifdef PLATFORM_OSX _main: %elifdef PLATFORM_LINUX main: %endif call socket_listen .ret: mov rax, SYSCALL(EXIT) mov rdi, 0 syscall . And also change build.sh: . #!/bin/bash FILES=(main socket) if [ \"PLATFORM_OSX\" = \"$1\" ] then FORMAT=\"macho64\" PLATFORM=\"$1\" else FORMAT=\"elf64\" PLATFORM=\"PLATFORM_LINUX\" fi OBJ_FILES=\"\" for f in ${FILES[@]} do echo 'Building: ' $f nasm -d$PLATFORM -f $FORMAT $f.s OBJ_FILES+=\"$f.o \" done echo \"Linking $OBJ_FILES\" if [ \"PLATFORM_OSX\" = \"$PLATFORM\" ] then gcc -Wl,-no_pie $OBJ_FILES -o server else gcc $OBJ_FILES -o server fi . To see what’s going on, we can use strace on Linux to trace system calls. You can use dtruss on OS X. Let’s run strace: . strace ./server . You can see these system calls in the bottom of the output: . socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3 bind(3, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr(\"0.0.0.0\")}, 16) = 0 listen(3, 5) = 0 exit(0) . So everything works as expected: . | The program first creates a socket with the correct arguments, and the socket descriptor 3 is returned from the socket call. | It calls bind with the correct address and port and no error is returned. | It calls listen with the returned socket file descriptor. It also returns success. | Program exits. | . strace is a really handy tool to analyze binaries. It tells a lot about what’s going on. So I suggest you experiment with it and read its manual. ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#running-our-server",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#running-our-server"
  },"30": {
    "doc": "x86_64 Tcp Server",
    "title": "Writing Some Helper Functions",
    "content": "Our program works but there are few things that I don’t like. | We are converting port number 4444 to the network byte-order by hand. That should be automized with a function. | Initializing the memory reserved for the address to zero is more convenient than setting the necessary fields to zero. | In .err_msg, we used a single length which is 20 and this is wrong. | . For the first part, let’s write a htons function that converts a 2-byte integer (short) from host byte order to network byte order. To do that we just need to swap, the byte order. In socket.s, on top of socket_listen: . ; htons(port) ; Convert 'port' to network byte-order. htons: ; Swap the first and the second byte of 'port'. mov dx, di mov ax, dx ; shift the least significant byte to left, so that it becomes the most significant byte. shl ax, 8 ; shift the MSB of `dx` to right, so that it becomes the LSB. shr dx, 8 ; mov the LSB of `rdx` to the LSB of `rax`. mov al, dl ret . You can see that we did not reserve a stack frame because we didn’t use the stack at all. You might not understand what’s going on at the first look, but please take your time and try to understand the function. I will not explain it :) . To ease things up, you can use gdb to debug the program. And run the function instruction by instruction. For the second part, let’s write a function that imitates memset. This function will set a particular memory to a value. In helper.s: . global h_memset ; memset(dst, x, n) ; starting from [dst], write 'x', to next 'n' bytes h_memset: mov rax, rsi mov rcx, rdx ; Starting from `rdi`, write `al` to `BYTE [rdi]`, ; and decrement `rcx`. Stop when `rcx` is zero. rep stosb ret . You can see that there is a weird instruction called rep stosb. Actually, it is not like ordinary instruction. It has two parts: . | rep means Repeat String Operation. It takes a string operation and repeatedly executes that operation. | It repeats an operation the number of times specified in rcx or until the specified condition is met. There are conditional rep’s REPE, REPNE and REPNZ. You can check them from the intel’s developer manual. | . | stosb means to store byte. | It stores al, in the memory location specified in rdi. | . | . Our function gets the destination address from rdi, byte to write from rsi and how many bytes to write from rdx. For the third part, let’s write a strlen function to find the length of the null-terminated strings. In helper.s: . global h_memset global h_strlen ; strlen(str) ; loop until '\\0' is seen and return length of 'str' h_strlen: ; We don't want the caller to lose the given string. push rdi ; `rbx` should be preserved.. push rbx mov rbx, rdi ; Set `rax` to zero as the null terminator. xor rax, rax ; Set `rcx` to zero and substract 1 from it, this makes ; it get the largest value possible. xor rcx, rcx dec rcx ; This time we use `repne` and `scasb`. `repne` will execute ; the string operation while ZF = 1. ; `scasb` will compare the value stored in the memory address ; `rdi` with `rax` and set EFLAGS accordingly. ; So if the destination byte is `rax` which is the null terminator, ; `repne` will stop executing. repne scasb ; Don't count the null terminator at the end of the string. sub rax, 2 ; Check how many times `rcx` is decremented. And that gives us the ; length of the string. sub rax, rcx pop rbx pop rdi ret . DIY: Use the helper functions in socket_listen. Then run and see if they work. If they do not work, don’t give up and use gdb to see what’s wrong. No pain, no gain. I really want you to integrate these functions into the program - and also I need a break :) - , so I will continue this post in the next part. Hopefully we will talk about the stack alignment, and complete our program. ",
    "url": "/docs/small-projects/x86_64-tcp-server.html#writing-some-helper-functions",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html#writing-some-helper-functions"
  },"31": {
    "doc": "x86_64 Tcp Server",
    "title": "x86_64 Tcp Server",
    "content": "May 23, 2021 . ",
    "url": "/docs/small-projects/x86_64-tcp-server.html",
    
    "relUrl": "/docs/small-projects/x86_64-tcp-server.html"
  }
}
