{"0": {
    "doc": "Home",
    "title": "Home",
    "content": "Hi, it's Abdullah. I am software engineer from Turkey :tr:. I am interested in Rust programming, operating systems, virtualization and distributed systems. In general, I am interested in how things work internally, and how to make them even better. Doing optimization, dealing with complex systems and problems, working close to hardware and sharing my knowledge are the things that I like. I want to share my learning experience as well as some informative material in this blog. Please feel free to contact :). ",
    "url": "/",
    "relUrl": "/"
  },"1": {
    "doc": "1. Introduction",
    "title": "1. Introduction",
    "content": "# Introduction I followed the first edition of [phil-opp's series](https://os.phil-opp.com/multiboot-kernel/). I didn't want to go with the newest version because it uses a helper tool that does too much. After I understand and experiment with the booting process, I'm gonna switch to the new version though. So, today's gainings are: - I skimmed through the [Multiboot Specification](https://nongnu.askapache.com/grub/phcoder/multiboot.pdf) and implement a simple Multiboot header in assembly. - I was familiar with assembly, and binary analysis tools like hexdump, objdump, etc. So I refreshed my knowledge about them. - I wrote my first linker script. I wasn't aware of they exist and it was cool. I wrote the below script, which defines the entry point as `start`, sets the load address of the first section to 1 MiB, and puts the multiboot header and the os code in order. One important thing is to run `ld` command with the parameter `-n` to disable the automatic section alignment. Otherwise the grub may not be able to find the Multiboot header. ``` ENTRY(start) SECTIONS { . = 1M; .boot : { /* ensure that the multiboot header is at the beginning */ *(.multiboot_header) } .text : { *(.text) } } ``` - I wrote a simple `grub` configuration file and generate an `iso` file. - I ran this simples OS possible in `qemu`. But since I use my Linux computer over ssh, I used `curses` instead of the GUI. I achieved this by running. ``` qemu-system-x86_64 -cdrom os.iso -curses -monitor stdio ``` `monitor` is used to be able to input commands to `qemu`. Otherwise you won't be able to exit from it. - I automate the build process by using `make`. - After understanding what's going on, I rewrote everything from scratch to have a more clear understanding. ## Next Step I will continue with [Entering Long Mode](https://os.phil-opp.com/entering-longmode/) post. ",
    "url": "/docs/os-dev-journey/introduction.html",
    "relUrl": "/docs/os-dev-journey/introduction.html"
  },"2": {
    "doc": "2. Long Mode",
    "title": "2. Long Mode",
    "content": "# Entering Long Mode To be able to use the features that comes with the long mode (such as 64-bit registers, multimedia registers, memory addresses that are higher than 4GiB), [the long mode](https://wiki.osdev.org/Setting_Up_Long_Mode) should be enabled. Before enabling the long mode, we should first check if it is supported by the CPU. First step is to detect if CPUID is supported. We use CPUID to check if long mode is supported. To detect the support for CPUID, we need to if 21. bit of `EFLAGS` can be modified. There are two notable instructions here: ``` pushfd ; push eflags to the stack popfd ; pop eflags from the stack ``` After this, CPUID should be called with the correct argument to check for the long mode support. CPUID accepts its argument from `eax` register. ``` mov eax, 0x80000000 ; Set the A-register to 0x80000000. cpuid ; CPU identification. cmp eax, 0x80000001 ; Compare the A-register with 0x80000001. jb .NoLongMode ``` This code from [OSDev](https://wiki.osdev.org/Setting_Up_Long_Mode#x86_or_x86-64) is calling `cpuid` with an argument to [get highest extended function implemented](https://en.wikipedia.org/wiki/CPUID#EAX=80000000h:_Get_Highest_Extended_Function_Implemented). If the returned value is smaller than `0x80000001`, we understand that the long mode is not supported. ``` mov eax, 0x80000001 ; Set the A-register to 0x80000001. cpuid ; CPU identification. test edx, 1 << 29 ; Test if the LM-bit, which is bit 29, is set in the D-register. jz .NoLongMode ; They aren't, there is no long mode. ``` Then the next code from [OSDev](https://wiki.osdev.org/Setting_Up_Long_Mode#x86_or_x86-64) is calling `cpuid` again to get the [extended processor info and feature bits](https://en.wikipedia.org/wiki/CPUID#EAX=80000001h:_Extended_Processor_Info_and_Feature_Bits) which returns the feature flags in `edx` and `ecx` registers. We check the 29. bit of `edx` to see if the long mode is supported. To have fun, I also wanted to print the vendor name of cpu. To get that information, we need to call `cpuid` with `eax = 0`, which returns the manufacturer id in `ebx`, `ecx` and `edx`. So we can write a function to call `cpuid` and print those 12 bytes to the screen. ``` print_cpu_vendor: mov eax, 0 cpuid ; push the returned characters with the correct order to stack so that ; we can easily iterate through them and be able to use the registers push ebx push ecx push edx ; for each character, we move the character to the vga buffer with the correct ; color code (in this case we use 0x2f for green background and white foreground) mov ecx, 0 .pcv_loop: cmp ecx, 12 je .pcv_end mov al, byte [esp + ecx] mov ebx, 0xb8000 lea edx, [ecx * 2] add ebx, edx mov byte [ebx], al add ebx, 1 mov byte [ebx], 0x2f add ecx, 1 jmp .pcv_loop .pcv_end: ; never forget to clean your mess pop eax pop eax pop eax ret ``` ## Next Step I will continue with [Entering Long Mode](https://os.phil-opp.com/entering-longmode/) post. ",
    "url": "/docs/os-dev-journey/long-mode.html",
    "relUrl": "/docs/os-dev-journey/long-mode.html"
  },"3": {
    "doc": "OS Dev Journey",
    "title": "OS Dev Journey",
    "content": "# My Operating System Development Journey I love to learn how things really work and build things from scratch. Since I am interested in virtualization, operating systems and work as an embedded software engineer, I wanted to give this a go. I made some research and prepared a plan for this. ## Gameplan First of all, O.S. development is a huge task and it won't be like \"making a to-do app from scratch\". There are many complex and low-level concepts that I need to learn, understand and experiment with. So I created a Trello page to note things that I should learn, or improve my knowledge. Secondly, writing about what I learned motivates me and makes it much more easier to things that I have done so far. So I will keep this blog up-to-date as much as possible. And finally, let's talk about the actual learning part. At first, I am planning to follow the [phill-opp's os development series](https://os.phil-opp.com). I think this series will give me not in-depth but good understanding of how things work. Since it is practical, and written mostly in Rust, I probably will enjoy this a lot. Then I think, I will proceed with [this course](https://www.educative.io/courses/operating-systems-virtualization-concurrency-persistence) which follows [this book](https://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters). While I follow these resources, I am gonna try to implement things by myself and experiment with different things. And of course, I will read and follow other great resources and documentations as well like the amazing [os-dev website](https://wiki.osdev.org). Let the journey begin! ",
    "url": "/blog/os-dev-journey",
    "relUrl": "/blog/os-dev-journey"
  }
}
